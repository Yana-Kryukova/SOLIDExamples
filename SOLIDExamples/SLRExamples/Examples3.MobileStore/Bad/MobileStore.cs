
namespace SLRExamples.Examples2.MobileStore.Bad
{
    internal class MobileStore
    {
        List<Phone> phones = new();
        public void Process()
        {
            // ввод данных
            Console.WriteLine("Введите модель:");
            string? model = Console.ReadLine();
            Console.WriteLine("Введите цену:");

            // валидация
            bool result = int.TryParse(Console.ReadLine(), out var price);

            if (result == false || price <= 0 || string.IsNullOrEmpty(model))
            {
                throw new Exception("Некорректно введены данные");
            }
            else
            {
                phones.Add(new Phone(model, price));
                // сохраняем данные в файл
                using (StreamWriter writer = new StreamWriter("store.txt", true))
                {
                    writer.WriteLine(model);
                    writer.WriteLine(price);
                }
                Console.WriteLine("Данные успешно обработаны");
            }
        }
    }
    #region Комментарии
    // Стоит понимать, что обязанности в классах не всегда группируются по методам.
    // Речь идет именно об обязанности компонента, в качестве которого может выступать не только тип (например, класс),
    // но и метод или свойство.И вполне возможно, что в одном каком-то методе сгруппировано несколько обязанностей.

    // Класс имеет один единственный метод Process, однако этот небольшой метод,
    // содержит в себе как минимум четыре обязанности:
    // ввод данных, их валидация, создание объекта Phone и сохранение.
    // В итоге класс знает абсолютно все: как получать данные, как валидировать, как сохранять.
    // При необходимости в него можно было бы засунуть еще пару обязанностей.
    // Такие классы еще называют "божественными" или "классы-боги",
    // так как они инкапсулируют в себе абсолютно всю функциональность.
    // Подобные классы являются одним из распространенных анти-паттернов, и их применения надо стараться избегать.

    // Хотя тут довольно немного кода, однако при последующих изменениях метод Process может быть сильно раздут,
    // а функционал усложнен и запутан.

    // Теперь изменим код класса, инкапсулировав все обязанности в отдельных классах:

    #endregion
}
